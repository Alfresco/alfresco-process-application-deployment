# Default values for chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  ## Configure pull secrets for all deployments
  registryPullSecrets:
    - "quay-registry-secret"

  keycloak:
    ## Configure Keycloak host template, i.e. "identity.{{ .Release.Namespace }}.{{ .Values.global.gateway.domain }}"
    host: 'identity.{{ template "common.gateway-domain" . }}'

    ## Set full url to configure external Keycloak, https://keycloak.mydomain.com/auth
    url: ""

    ## Configure Keycloak realm
    realm: "alfresco"
    resource: "activiti"
    client: "activiti"

  gateway:
    ## Set to configure single domain name for all services, i.e. "gateway.{{ .Release.Namespace }}.{{ .Values.global.gateway.domain }}"
    host: 'gateway.{{ template "common.gateway-domain" . }}'

    ## Set to false enables HTTPS configuration on all urls
    http: "false"

    ## Set to enable automatic TLS for ingress if https is enabled
    tlsacme: "false"

    ## Set to configure gateway domain template, i.e. {{ .Release.Namespace }}.1.3.4.5.nip.io
    #  helm upgrade activiti . --install --set global.gateway.domain=1.2.3.4.nip.io
    domain: "REPLACEME"

    ## Configure global annotations for all service ingresses, i.e.
    annotations: {}
    
  acs:
    host: 'acs.{{ template "common.gateway-domain" . }}' 

# set to false to disable custom alfresco-identity-service ingress with hostname support
alfresco-identity-service:
  ingress:
    enabled: true
    annotations: 
      # Disable Nginx CORS for Identity Service 
      nginx.ingress.kubernetes.io/enable-cors: "false"

alfresco-infrastructure:
  enabled: true
  persistence:
    enabled: false
  alfresco-event-gateway:
    enabled: false
  activemq:
    enabled: false
  nginx-ingress:
    enabled: false
    controller:
      scope:
        enabled: false
  alfresco-identity-service:
    enabled: true
    ingress:
      enabled: false
    keycloak:
      postgresql:
        imageTag: "11.3"
        persistence:
          existingClaim: null # use default postgresql PVC    
      keycloak:
        service:
          port: 80
        extraArgs: "-Dkeycloak.import=/realm/alfresco-aps-realm.json"
        # Add explicit support for HTTPS proxy address forwarding
        extraEnv: |
          - name: PROXY_ADDRESS_FORWARDING
            value: "true"
    realm:
      alfresco:
        client:
          redirectUris:
            - "*"
          webOrigins:
            - "*"

alfresco-digital-workspace: &alfresco-digital-workspace
  enabled: false # disables the one from ACS, this one is enabled with alfresco-content-services.alfresco-digital-workspace.enabled
  nameOverride: "alfresco-digital-workspace"
  ingress:
    hostName: '{{ include "alfresco-process-infrastructure.acs-host" . }}' # Requires host rule in ingress
    path: /workspace
    annotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "500m"
  image:
    repository: quay.io/alfresco/alfresco-digital-workspace
    tag: 1.1.0
    internalPort: 8080
    pullPolicy: IfNotPresent
  env:
    APP_CONFIG_ECM_HOST: '{{ include "alfresco-process-infrastructure.acs-url" . }}'
    APP_CONFIG_AUTH_TYPE: "OAUTH"
    BASEPATH: "{{ .Values.ingress.path }}/"
    APP_CONFIG_IDENTITY_HOST: '{{ include "common.keycloak-url" . }}/admin/realms/{{ include "common.keycloak-realm" . }}'

alfresco-content-services:
  enabled: false
  alfresco-infrastructure:
    enabled: false
    activemq:
      enabled: true
      # Workaround Helm NPE
      adminUser:
        username: admin
        password: admin
  externalHost: '{{ template "alfresco-process-infrastructure.acs-host" . }}'
  externalProtocol: '{{ template "common.gateway-proto" . }}'
  externalPort: '{{ if eq "true" (toString .Values.global.gateway.http) }}80{{ else }}443{{ end }}'
  registryPullSecrets: quay-registry-secret

  # Disabled for global nginx ingress controller
  networkpolicysetting:
    enabled: false

  repository:
    replicaCount: 1
    ingress:
      hostName: '{{ template "alfresco-process-infrastructure.acs-host" . }}'
      path: "/alfresco"
      maxUploadSize: "500m"
    readinessProbe:
      initialDelaySeconds: 140
    environment:
      IDENTITY_SERVICE_URI: '{{ template "alfresco-process-infrastructure.keycloak-url" . }}'
      IDENTITY_SERVICE_REALM: "alfresco"
      IDENTITY_SERVICE_RESOURCE: "activiti"
      JAVA_OPTS: "
        -Dsolr.base.url=/solr
        -Dsolr.secureComms=none
        -Dindex.subsystem.name=solr6
        -Dalfresco.cluster.enabled=true
        -Ddeployment.method=HELM_CHART
        -Xms1800M -Xmx1800M
        -Dauthentication.chain=identity-service1:identity-service,alfrescoNtlm1:alfrescoNtlm
        -Didentity-service.enable-basic-auth=true
        -Didentity-service.authentication.validation.failure.silent=false
        -Didentity-service.auth-server-url=\"$IDENTITY_SERVICE_URI\"
        -Didentity-service.realm=\"$IDENTITY_SERVICE_REALM\"
        -Didentity-service.resource=\"$IDENTITY_SERVICE_RESOURCE\"
        -Dlocal.transform.service.enabled=false
        -Dtransform.service.enabled=false
      "

  share:
    replicaCount: 1
    ingress:
      hostName: '{{ template "alfresco-process-infrastructure.acs-host" . }}'

  imagemagick:
    replicaCount: 1 # 2 instances by default

  libreoffice:
    replicaCount: 1 # 2 instances by default

  pdfrenderer:
    replicaCount: 1 # 2 instances by default

  tika:
    replicaCount: 1 # 2 instances by default

  transformrouter:
    replicaCount: 1 # 2 instances by default

  alfresco-digital-workspace: *alfresco-digital-workspace

  postgresql:
    imageTag: "11.3"
    persistence:
      existingClaim: null # use default 

nfs-server-provisioner:
  enabled: false
  persistence:
    enabled: true
    ## Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  ('default' on AKS, 'gp2' on AWS, 'standard' on GKE & OpenStack)
    ##
    storageClass: null
    size: 200Gi

  storageClass:
    defaultClass: false

persistence:
  name: '{{ index .Values "alfresco-content-services" "persistence" "existingClaim" }}'
  storageClass:
    name: '{{ index .Values "nfs-server-provisioner" "storageClass" "name" }}'
    accessModes:
      - ReadWriteMany
  baseSize: 100Gi    

postgresql-ams:
  imageTag: "11.3"
  postgresUser: alfresco
  postgresPassword: alfresco
  postgresConfig:
    max_connections: 300
    log_min_messages: LOG
  resources:
    requests:
      memory: "1500Mi"
    limits:
      memory: "1500Mi"

alfresco-modeling-service:
  nameOverride: alfresco-modeling-service
  rbac:
    create: false
  serviceAccount:
    create: false
  ingress:
    enabled: true
    path: "/modeling-service"
  extraVolumes: |
    - name: license
      secret:
        secretName: licenseaps
  extraVolumeMounts: |
    - name: license
      mountPath: "/root/.activiti/enterprise-license/"
      readOnly: true
  image:
    repository: quay.io/alfresco/alfresco-modeling-service
    tag: "2.2.0"
    pullPolicy: Always
  postgres:
    enabled: true
    name: postgresql-ams
    username: alfresco
    password: alfresco
  probePath: "{{ .Values.ingress.path }}/actuator/health"
  extraEnv: |
    - name: SERVER_PORT
      value: "8080"
    - name: SERVER_SERVLET_CONTEXTPATH
      value: "{{ .Values.ingress.path }}"
    - name: SERVER_USEFORWARDHEADERS
      value: "true"
    - name: SERVER_TOMCAT_INTERNALPROXIES
      value: ".*"
    - name: MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE
      value: "*"

alfresco-modeling-app:
  nameOverride: "alfresco-modeling-app"
  ingress:
    path: /modeling
  image:
    repository: quay.io/alfresco/alfresco-modeling-app
    tag: "2.2.0"
    pullPolicy: IfNotPresent
  env:
    APP_CONFIG_AUTH_TYPE: "OAUTH"
    APP_CONFIG_OAUTH2_SILENT_LOGIN: "true"
    APP_CONFIG_BPM_HOST: '{{ include "common.gateway-url" . }}/modeling-service'

postgresql-ads:
  imageTag: "11.3"
  postgresUser: alfresco
  postgresPassword: alfresco
  postgresConfig:
    max_connections: 300
    log_min_messages: LOG
  resources:
    requests:
      memory: "1500Mi"
    limits:
      memory: "1500Mi"  

alfresco-deployment-service:
  alfresco-content-services:
    enabled: false
  enabled: true
  rbac:
    create: false
  serviceAccount:
    create: false
  rabbitmq:
    enabled: false
  image:
    repository: quay.io/alfresco/alfresco-deployment-service
    # temporary until released
    tag: "2.2.0"
    pullPolicy: Always
  postgres:
    enabled: true
    name: postgresql-ads
    username: alfresco
    password: alfresco
  securityContext: |
    privileged: true
  ingress:
    path: /deployment-service
    enabled: true
  probePath: "{{ .Values.ingress.path }}/actuator/health"
  dockerRegistry:
    server: ""
    password: ""
    userName: ""
    secretName: "aps2-registry-secret"
  environment:
    apiUrl: ""
    apiToken: ""
  extraVolumes: |
    - name: config
      configMap:
        name: {{ .Release.Name }}-deployment-config
        defaultMode: 0744
    - name: docker-sock-volume
      hostPath:
        path: /var/run/docker.sock
        type: File
    - name: license
      secret:
        secretName: licenseaps
  extraVolumeMounts: |
    - name: docker-sock-volume
      mountPath: /var/run/docker.sock
    - name: license
      mountPath: "/root/.activiti/enterprise-license/"
      readOnly: true
  extraInitContainers: |
    {{- if index .Values "alfresco-content-services" "enabled" -}}
    - name: wait-for-acs
      image: "alpine:3.8"
      imagePullPolicy: IfNotPresent
      command:
        - sh
        - -c
        - |
          until printf "." && nc -z -w 2 {{ .Release.Name }}-alfresco-cs-repository 80; do
              sleep 2;
          done;

          echo 'ACS OK âœ“'
    - name: init
      image: bitnami/minideb-extras
      command: ["/bin/bash"]
      args:
        - -c
        - /tmp/init/setup_acs.sh
      env:
        - name: "GATEWAY_URL"
          value: {{ template "alfresco-process-infrastructure.acs-url" . }}
      volumeMounts:
        - name: config
          mountPath: /tmp/init
    {{- end -}}
  extraEnv: |
    - name: SERVER_PORT
      value: "8080"
    - name: SERVER_SERVLET_CONTEXTPATH
      value: "{{ .Values.ingress.path }}"
    - name: SERVER_USEFORWARDHEADERS
      value: "true"
    - name: SERVER_TOMCAT_INTERNALPROXIES
      value: ".*"
    - name: MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE
      value: "*"
    - name: KEYCLOAK_AUTH_SERVER_URL
      value: '{{ include "common.keycloak-url" . }}'
    - name: DOCKER_REGISTRY_SERVER
      value: "{{ .Values.dockerRegistry.server }}"
    - name: DOCKER_REGISTRY_USERNAME
      value: "{{ .Values.dockerRegistry.userName }}"
    - name: DOCKER_REGISTRY_PASSWORD
      value: "{{ .Values.dockerRegistry.password }}"
    - name: DOCKER_REGISTRY_SECRET_NAME
      value: "{{ .Values.dockerRegistry.secretName }}"
    - name: DOCKER_REGISTRY_IMAGE_TAG
      value: "2.2.0"
    - name: CONTENT_SERVICE_BASE_URL
      value: '{{ template "alfresco-process-infrastructure.acs-url" . }}'
    - name: CONTENT_SERVICE_ENABLED
      value: '{{ index .Values "alfresco-content-services" "enabled" }}'
    - name: MODELING_URL
      value: '{{ include "common.gateway-url" . }}/modeling-service'
    - name: ENVIRONMENT_HOST_URL
      value: '{{ include "common.gateway-url" . }}'
    - name: ENVIRONMENT_API_URL
      value: "{{ .Values.environment.apiUrl }}"
    - name: ENVIRONMENT_API_TOKEN
      value: "{{ .Values.environment.apiToken }}"

alfresco-admin-app:
  nameOverride: "alfresco-admin-app"
  ingress:
    hostName:
    path: /admin
  image:
    repository: quay.io/alfresco/alfresco-admin-app
    tag: "2.2.0"
    pullPolicy: IfNotPresent
  env:
    APP_CONFIG_BPM_HOST: '{{ include "common.gateway-url" . }}'
    APP_CONFIG_AUTH_TYPE: "OAUTH"
    APP_CONFIG_IDENTITY_HOST: '{{ include "common.keycloak-url" . }}/admin/realms/{{ include "common.keycloak-realm" . }}'
